# 多处理机系统进程同步

## 集中式与分布式同步方式

### 集中式同步机构

同步实体（Synchronizing Entity）（例如硬件锁、信号量）满足

- 具有唯一名字，并且为彼此必须同步的所有进程所知道
- 在任何时刻，这些进程中的任何一个都可以访问该同步实体

两个条件，则成为中心同步实体。

基于中心实体所构成的所有同步机构称为集中式同步机构。

### 集中式与分布式算法

- 集中式算法：中心控制节点判定多个进程需要同时访问共享资源或进行通信时，哪一个进程执行，判定所需要的信息全部集中在中心控制节点。
- 分布式算法：所有节点具有相同的信息，所有节点仅基于本地信息作出判断，所有节点要付出同样的工作量

### 中心进程方式

系统中设置一个中心进程（或称协调进程），该进程保存所有用户的存取权限、冲突图等信息。任何一个进程要进入临界区，都需要向中心进程请求、中心进程回答、向中心进程释放三个消息。

## 集中式同步机构

### 自旋锁（spin lock）

自旋锁只允许被一个内核进程持有，在总线上设置一个自旋锁，内核进程需要使用总线对某个存储单元进行读写时，要先请求自旋锁，并循环测试自旋锁直到自旋锁可用。

一般自旋锁保护的临界区较短，采用循环测试而不是挂起进程，能减少切换进程所消耗的资源。

### 读-拷贝-修改（Read-Copy-Update）锁

对于被 RCU 保护的共享文件（数据结构），进程都以读的形式访问。对写进程而言，在访问文件时，需先制作该文件的副本，对文件副本进行修改，并使用一个回调（callback）机制（向系统中一个称为垃圾收集器的机构注册一个回调函数），在适当的时机（读进程完成对共享文件的操作，会向写进程提供一个信号，收到所有读进程的信号时为适当时机），由垃圾收集器用写进程注册的回调函数，把指向原来数据的指针重新指向新的被修改的数据，并释放原来数据。

### 二进制指数补偿算法

为每一个 CPU 对锁进行测试的 TSL 指令设置一个指令延迟执行时间，延迟时间为2的测试次数幂。减少了测试次数，减少总线流量。

### 待锁 CPU 等待队列机构

为每个 CPU 配置一个用于测试的私有变量和一个记录待锁 CPU 的待锁清单，存放在其私有的高速缓存中。当多个 CPU 需要互斥访问某个共享数据结构时，若该结构已被占用，则为每个未获得锁的 CPU 分配一个锁变量，并依次附在占用该共享数据结构 CPU 的待锁清单末尾；当共享数据结构的占有 CPU 退出临界区时，从私有的高速缓存中查找待锁清单，并释放第一个 CPU 的私有锁变量。

## 定序机构

### 时间戳定序机构（Timestamp Ordering Mechanism）

系统中具有唯一的、有单一物理时钟驱动的物理时钟体系，确保各处理机时钟严格同步。对每一特殊事件（例如资源请求、通信）都印上唯一时间戳，根据时间戳定义所有时间的全序，由此配以相应的算法实现不同处理机的同步进程（可以是集中式或分布式）。

### 事件计数（Event Count）同步机构

使用一个称为定序器（Sequencers）的整型量，为所有特定事件进行排序。定序器初值为0，对其仅能施加 ticket(S) 操作，当一个事件发生时，系统便为之分配一个称为编号（或标号）V 的序号，ticket 自动加1，然后将打上标号的事件送至等待服务队列排队。同时，系统保留所有已服务事件的标号，并形成一个称为事件计数 E 的栈。

对事件计数有三种操作：

```C
// 进程进入临界区之前
await(E,V){
    if(E<V){
        i=EP;
        stop();
        i->status="block";
        i->sdata=EQ;
        insert(EQ,i);
        scheduler();
    }
    else continue;
}
// 进程退出临界区之时
advance(enentcount E){
    E++;
    if(EQ<>NIL){
        V=inspect(EQ,1);
        if(E==V) wakeup(EQ,1);
    }
}
read(E){
    // 返回 E 的当前值供进程参考，以此决定是否转去处理其他事件
}
```

## 分布式进程同步算法

### 面包房算法

利用事件排序的方法对要求访问临界资源的全部事件进行排序，按 FCFS 次序处理事件，若完成访问的事件需要再次访问，则重新排队。

算法步骤如下：

1. 当进程 Pi 请求资源时，它把请求消息 Request(Ti,i)，Ti 为进程 Pi 发送此消息时对应的逻辑时钟值，i 代表消息内容。
2. 当进程 Pj 接收到外来消息 Request(Ti,i)后，发送回答消息 Reply(Tj,j)，并把 Request(Ti,i) 放入自己的请求队列，Tj=min(Ti, 进程 Pj 对统一资源提出请求的时间)。
3. 若 Pi 自身请求访问某一资源的消息处于请求队列的最前面，且 Pi 已收到从其他进程发来是回答消息的时间戳均晚于 (Ti,i)，则允许进程 Pi 访问该资源。
4. 释放资源时，Pi 从自己队列中撤销请求消息，并发送一个打上时间戳的释放消息 Release 给其他进程。其他进程收到 Release 消息后，撤销自己队列中原 Pi 的 Request(Ti,i) 的消息。

### 令牌环算法

将所有进程组成一个逻辑环（Logical Ring），系统中设置一个象征存取权力的令牌（Token，一种特定格式的报文），在进程所组成的逻辑环中，不断按固定方向和顺序循环传递，获得令牌的进程才得以进入临界区访问共享资源一次。

## ChangeLog

> 2018.10.05 初稿